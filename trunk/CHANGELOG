[2009.10.27] Fixed a nasty bug about EFLAGS.TF. Now the flag is set correctly. The logger will show exactly how many times the memory address is accessed now.

[2009.10.28] Added LIST1_FOREACH_DELETABLE Macro to List.h.

[2009.10.28] Solved the problem about remapping attack. This kind of attack functions as this: the attacker first allocate a memory area, and then write the data he want on it. Then he remap the other area(Such as the SSDT) to the physical memory area pointed by the virtual address he allocated. After this, the system would still read on the old area(Such as SSDT), but getting the data written by him. I solve this problem by monitor the remap procedure, and after the remap i scan the whole page table to make sure that every virtual address mapped to the new physical page is monitored.

[2009.10.30] Fixed the most nasty problem which prevent it from working correctly on MP machines. As the FXXKING windows would dispatch threads on different processors, the problem shows out. When Rkanalyzer set EFLAGS.TF and wait for the guest VM to return with the #DB exception, it hands out the excution to the guest; we record the CPU now, say, CPU 0. However, the FXXKING windows sometimes dispatch the thread that is on the TF flag to another processor, say, CPU 3. OK, now the instruction is executed, and cause a VM Exit with #DB. But this is not we want, because we get a #DB on CPU 3, instead of CPU 0. Now the flags we set in the VMM host for CPU 0 is lost, and we'll never know that the #DB was set by CPU 0 by any means. This really hurts, because if we lost the flag then the CPU would inject the #DB exception back to the guest, which causes a BSOD in windows kernel, say KERNEL_EXCEPTION_NOT_HANDLED.
    The ONLY way i thought about how to handle it is to limit the excution on the CPU we set the EFLAGS.TF. By this we can disable the FXXKING thread dispatch mechanism of windows. To do this, we have to halt the other CPUs, but i'd say that hlt would not be good, i'd rather choose spin-loop. However, we have to find a method to inform all other CPUs to enter the loop, even if they are unawared about what happened in this CPU. The only method is through the APIC, which could invoke a IPI(Inter-processor-interrupt) to cause other CPUs into VMExit. However, which interrupt do we choose is a problem. We want a high priority interrupt, and rarely be used by the operating system(to reduce potential conflict). So, INIT signal makes a good choice. We also set a flag to show that the INIT is send for sync, rather than want the system to reboot.
    The last problem is what we should do if other CPUs receive the interrupt when they are already in VMExit. As the interrupt would be delivered once they VMEntry into the guest, and then the INIT VMExit will occur; but if the flag to distinguish the real and artifical INIT is already set back, these CPUs would treat this INIT as a real INIT rather than a artifical one. This would cause the system to reboot. To prevent from this, we hold a counter for each CPU, to remember how much artifical INITs they received but not consumed. When they are ready to consume these artifical INITs, we reduce the counter one by one to make sure that all artifical ones have been consumed before the real one would come.
    P.S: thanks to the FXXKING MP SYSTEM, i worked 3 days on these trival matters. Well, i learned about using "LOCK" prefix instuctions through the work, and knew about that not only writing to shraed data should use "LOCK", reading should also use it. It's really great.

[2009.12.11] Finally I get rid of the method using INIT signal for sync above. In fact, to limit the execution of the single-stepping instruction on one CPU, we only need to set the EFLAGS.IF = 0 on that CPU, so the timer interrupt will be masked thus no dispatching would occur. 

[2009.12.12] Add Readonly sections of Windows Kernel Executive(Ntoskrnl) to protection area. Also, as I want to test if the protection would hurt innocent areas, I add some extra pages to monitor(but not protection). Such pages would result in crash when I was using INIT signal for sync. But now it seems working well as I changed to disabling the interrupt.

[2009.12.12] Add minor fix for security issues. Including: [1]Original Protect Area remapped to another Original Area. [2]When guest modified Page table and used invlpg to refresh the TLB. The program will now maintain the protect area in issues above.

[2009.12.12] Add lock to mm_protect_area operations. Now the it works well on MP System.
